---
title: "BTC CytAssist Pilot"
author: "LTKAGOHARA"
date: "2024-12-04"
output:
  html_document: default
  pdf_document: default
params:
  spaceranger_dir: "~/OneDrive/BTC_DPTpilot1_spaceranger/BTC"
  coda_ann_path: "~/OneDrive/CODA/H13/tissue_positions_cellular_compositions.csv"
  output_dir: "analysis_pilot"
  sample_name: "BTC"
---

# VISIUM DATA ANALYSIS WITH SEURAT
# Incorporating CODA for cell type annotations

##### Loading packages
```{r}
library(Seurat)
library(ggplot2)
library(leiden)
library(patchwork)
library(dplyr)
library(rhdf5)
library(ggrepel)
library(Rfast2)
library(EnhancedVolcano)
library(fgsea)
library(msigdbr)
library(RColorBrewer)
library(ggpubr)
library(MAST)
```

## Increasing the allowed memory to avoid errors regarding lack of memory
```{r}
options(future.globals.maxSize = 1024 * 1024 * 1024)  # 1 GB
```

## Loading the data for sample BTC
```{r}
BTC <- Load10X_Spatial(params$spaceranger_dir)
dim(BTC)
head(BTC@meta.data)
```

## INTEGRATING CODA CELL CLASSIFICATION INTO METADATA
```{r}
# extract BTC metadata
BTCmetadata <- BTC@meta.data

# uploading CODA annotations
codaBTC <- as.data.frame(read.csv(params$coda_ann_path))
rownames(codaBTC) <- codaBTC$X
codaBTC <- codaBTC[, -c(1, 2, 3, 4, 5, 6)]
head(codaBTC)

# merging CODA annotations to metadata
BTCmetadata <- merge(BTCmetadata, codaBTC, by = "row.names")

# assigning cell types from CODA quantifications per spot (barcode)
BTCmetadata$CODA <- "mixed"
BTCmetadata$CODA[BTCmetadata$RespondingPDAC > 51] <- "responding"
BTCmetadata$CODA[BTCmetadata$NonrespondingPDAC > 51] <- "non-responding"
BTCmetadata$CODA[BTCmetadata$Stroma > 51] <- "stroma"
BTCmetadata$CODA[BTCmetadata$Immune > 51] <- "immune"
BTCmetadata$CODA[BTCmetadata$Vasculature > 51] <- "vasculature"
BTCmetadata$CODA[BTCmetadata$Fat > 51] <- "fat"
BTCmetadata$CODA[BTCmetadata$Acini > 51] <- "acini"
BTCmetadata$CODA[BTCmetadata$Islets > 51] <- "islets"
BTCmetadata$CODA[BTCmetadata$Nerve > 51] <- "nerve"
BTCmetadata$CODA[BTCmetadata$Duct > 51] <- "normal duct"
BTCmetadata$CODA[BTCmetadata$RespondingPDAC == 0 & 
                 BTCmetadata$NonrespondingPDAC == 0 & 
                 BTCmetadata$Stroma == 0 & 
                 BTCmetadata$Immune == 0 &
                 BTCmetadata$Vasculature == 0 &
                 BTCmetadata$Fat == 0 &
                 BTCmetadata$Acini == 0 &
                 BTCmetadata$Islets == 0 &
                 BTCmetadata$Nerve == 0 &
                 BTCmetadata$Duct == 0] <- "NA"
table(BTCmetadata$CODA)

BTC <- AddMetaData(object = BTC, metadata = BTCmetadata)
head(BTC)
```

##### saving object with CODA classification
```{r}
save(BTC, file = "BTC_CODA.Rda")
```

# DATA PREPROCESSING

## QC and filtering
```{r}
load("BTC_CODA.Rda")

# proportion of mitochondrial reads
BTC[["percent_mt"]] <- PercentageFeatureSet(BTC, pattern = "^MT-")
head(BTC@meta.data)

VlnPlot(BTC, features = c("nFeature_Spatial", "nCount_Spatial", "percent_mt"), ncol = 3)
ggsave("BTC_QC1.png")

plot1 <- FeatureScatter(BTC, feature1 = "nCount_Spatial", feature2 = "percent_mt")
plot2 <- FeatureScatter(BTC, feature1 = "nCount_Spatial", feature2 = "nFeature_Spatial")
wrap_plots(plot1, plot2)
ggsave("BTC_QC2.png")

# plots to verify the variance in counts across spots
plot3 <- VlnPlot(BTC, features = "nCount_Spatial", pt.size = 0.1) + NoLegend()
plot4 <- SpatialFeaturePlot(BTC, features = "nCount_Spatial", pt.size.factor = 7) + theme(legend.position = "right")
wrap_plots(plot3, plot4)
ggsave("BTC_QC3.png")

# NOTE: data looks good quality and spots were not filtered out of the analysis
```

##### saving filtered dataset
```{r}
save(BTC, file = "BTC_filtered.Rda")
```

## NORMALIZATION WITH SCTransform
```{r}
load("BTC_filtered.Rda")

BTC <- SCTransform(BTC, assay = "Spatial", vars.to.regress = "percent_mt",verbose = F)
```

##### saving SCTransformed data
```{r}
save(BTC, file = "BTC_SCTransformed.Rda")
```

## DIMENSIONALITY REDUCTION, CLUSTERING, VISUALIZATION
```{r}
load("BTC_SCTransformed.Rda")

BTC <- RunPCA(BTC, assay = "SCT")
DimPlot(BTC, reduction = "pca")

# cluster spots
BTC <- FindNeighbors(BTC, reduction = "pca", dims = 1:30)
BTC <- FindClusters(BTC, algorithm = 4)

# run UMAP for dimensional reduction
BTC <- RunUMAP(BTC, reduction = "pca", dims = 1:30)

# creating a palette of colors that fits 15 clusters
colorcount <- length(unique(BTC$SCT_snn_res.0.8))
myPalette <- colorRampPalette(brewer.pal(12, "Paired"))

DimPlot(BTC, reduction = "umap", label = TRUE)
ggsave("BTC_Dimplot.png")
SpatialDimPlot(BTC, label = T, label.size = 2.5, pt.size.factor = 7) + 
  scale_fill_manual(values = myPalette(colorcount))
ggsave("BTC_clustering_res08.png")

# highligthing specific clusters (cluster by cluster plot)
# all clusters
SpatialDimPlot(BTC, 
               cells.highlight = CellsByIdentities(object = BTC,idents = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
                                                                             11, 12, 13, 14, 15, 16, 17)),
               facet.highlight = T, ncol = 6, pt.size.factor = 7, image.alpha = 1, alpha = 0.5)

ggsave("BTC_cluster_highlights_res08.png")
```

##### saving reduced data
```{R}
save(BTC, file = "BTC_clustered.Rda")
```

## FINDING CLUSTER MARKER GENES
```{r}
load("BTC_clustered.Rda")

### find all markers in each cluster distinguishing one cluster from all other spots
markers_BTC <- FindAllMarkers(BTC, test.use = "MAST",only.pos = T, min.pct = 0.25, logfc.threshold = 0.25)
markers_df <- as.data.frame(markers_BTC %>% group_by(cluster) %>% slice_max(n = 10, order_by = avg_log2FC))
DoHeatmap(BTC,features = markers_df$gene)
ggsave("BTC_markersHM.png")
```

## INDENTIFYING HIGHLY VARIABLE SPATIAL FEATURES
```{r}
# FindSpatiallyVariables search for features without pre-annotation
# "markvariogram" finds genes whose expression depends on spatial location
BTC <- FindVariableFeatures(BTC, selection.method = "vst", nfeatures = 2000)
topBTC_varfeat <- head(VariableFeatures(BTC), 10)
topBTC_varfeat

BTC <- FindSpatiallyVariableFeatures(BTC, assay = "SCT", 
                                     features = VariableFeatures(BTC)[1:2000], 
                                     selection.method = "moransi")
top_features <- head(VariableFeatures(BTC, method = "moransi"), 20)
SpatialFeaturePlot(BTC, features = top_features, ncol = 5, alpha = c(0.1,1))
ggsave("BTC_varfeatures.png")
```

##### saving variable features data
```{r}
save(BTC, file = "BTC_VarFeatures.Rda")
```

## SETTING CODA AS ACTIVE IDENTITIES
```{r}
load("BTC_VarFeatures.Rda")

# making CODA annotations the active identities
Idents(BTC) <- "CODA"
table(Idents(BTC))

SpatialDimPlot(BTC, label = T, label.size = 2.5, pt.size.factor = 5, cols = "Paired")
ggsave("BTC_clustering_CODA.png")

SpatialDimPlot(BTC, 
               cells.highlight = CellsByIdentities(object = BTC,idents = c("responding", "non-responding", "stroma", 
                                                                             "immune", "vasculature",  "fat", "acini", 
                                                                             "islets", "nerve", "normal duct", "mixed")),
               facet.highlight = T, ncol = 6, pt.size.factor = 7, image.alpha = 1, alpha = 0.5)

ggsave("BTC_cluster_highlights_CODA.png")

markers_BTC <- FindAllMarkers(BTC, test.use = "MAST",only.pos = T, min.pct = 0.25, logfc.threshold = 0.25)
codamarkers_df <- as.data.frame(markers_BTC %>% group_by(cluster) %>% slice_max(n = 10, order_by = avg_log2FC))
DoHeatmap(BTC,features = codamarkers_df$gene)
ggsave("BTC_markersHM_CODA.png")
```

##### saving the object using the CODA annotations as active idents
```{r}
save(BTC, file = "BTC_CODAidents.Rda")
```

## Differential expression analysis with CODA annotations
```{r}
load("BTC_CODAidents.Rda")

DGEA <- FindMarkers(BTC, test.use = "MAST", ident.1 = "responding", ident.2 = "non-responding", logfc.treshold = 0.1, min.pct = 0.1)
dgea_df <- as.data.frame(DGEA)

top_genes <- rownames(DGEA)[order(DGEA$p_val_adj)][1:10]

EnhancedVolcano(dgea_df, 
                lab = rownames(dgea_df), 
                x = 'avg_log2FC', 
                y = 'p_val',
                title = 'responding vs. non-responding',
                pCutoff = 1e-2,
                FCcutoff = 1,
                pointSize = 0.5,
                xlim = c(-1.5, 1.5), 
                ylim = c(0, 5), 
                labSize = 4.0)
ggsave("BTC_DGEA_volcano.png")
write.csv(dgea_df, file = "BTC_DGEA_output.csv")

# GSEA
# ranking genes
ranks <- dgea_df$avg_log2FC
names(ranks) <- rownames(dgea_df)
head(ranks)
ranks <- sort(ranks, decreasing = TRUE) # sorting genes by ranking
plot(ranks)

# loading MSigDB Hallmark pathways for mouse
hs_df = msigdbr(species = "Homo sapiens", category = "H")

# converting to list format
hs_list = hs_df %>% split(x = .$gene_symbol, f = .$gs_name)

# Show the first few pathways, and within those, show only the first few genes. 
hs_list %>% 
  head() %>% 
  lapply(head)

# running fgsea
fgseaRes <- fgseaMultilevel(pathways = hs_list, 
                            stats = ranks, 
                            scoreType = "std", 
                            nPermSimple = 10000, 
                            nproc = 1)
head(fgseaRes)
save(fgseaRes, file = "BTC_fgsea_hallmarks.Rda")

ggplot(fgseaRes, aes(reorder(pathway, NES), NES)) +
  geom_col(aes(fill=pval<0.05)) +
  coord_flip() +
  labs(x="Pathway", y="Normalized Enrichment Score",
       title="Hallmark pathways NES from GSEA") + 
  theme_minimal()
ggsave("BTC_GSEA_NES_waterfall.png")
```


## Identifying PDAC transcriptional subtypes
```{r}
### AddModuleScore for PDAC subtypes (Moffitt classification - classical and basal-like)

load("BTC_CODAidents.Rda")

# subsetting for epithelial cells
BTCepit <- subset(BTC, idents = c("responding", "non-responding", "normal duct"))
SpatialDimPlot(BTCepit, label = T, label.size = 2.5, pt.size.factor = 5, cols = "Paired")

save(BTCepit, file = "BTC_Epithelial.Rda")

# PDAC basal subtype
basal_genes <- list(c('VGLL','UCA1','S100A2','LY6D','SPRR3','SPRR1B','LEMD1','KRT15',
                      'CTSL2','DHRS9','AREG','CST6','SERPINB3','KRT6C','KRT6A','SERPINB4',
                      'FAM83A','SCEL','FGFBP1','KRT7','KRT17','GPR87','TNS4','SLC2A1',
                      'ANXA8L2'))
BTCepit <- AddModuleScore(BTCepit, features = basal_genes, name = 'basal')
SpatialFeaturePlot(BTCepit, features = 'basal1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC_basal.png")

VlnPlot(BTCepit, features = 'basal1')
ggsave("BTC_basal_vln.png")

# PDAC classical subtype
classical_genes <- list(c('BTNL8','FAM3D','ATAD4','AGR3','CTSE','LOC400573','LYZ','TFF2',
                          'TFF1','ANXA10','LGALS4','PLA2G10','CEACAM6','VSIG2','TSPAN8',
                          'ST6GALNAC1','AGR2','TFF3','CYP3A7','MYO1A','CLRN3','KRT20',
                          'CDH17','SPINK4','REG4'))
BTCepit <- AddModuleScore(BTCepit, features = classical_genes, name = 'classical')
SpatialFeaturePlot(BTCepit, features = 'classical1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC_classical.png")

VlnPlot(BTCepit, features = 'classical1')
ggsave("BTC_classical_vln.png")
```

## Identifying CAF subtypes
```{r}
### AddModuleScore for CAF subtypes

load("BTC_CODAidents.Rda")

# subsetting for stroma
BTCstroma <- subset(BTC, idents = "stroma")
save(BTCstroma, file = "BTC_Stroma.Rda")

# panCAFs
pancaf_genes <- list(c('LUM','DCN','COL1A1','VIM','CD39','FSP1','FAP','ACTA2','PDPN'))
BTCstroma <- AddModuleScore(BTCstroma, features = pancaf_genes, name = 'panCAF')
SpatialFeaturePlot(BTCstroma, features = 'panCAF1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC_panCAF.png")

# iCAFs
iCAF_genes <- list(c('CXCL1','CXCL2','CCL2','CXCL12','PDGFRA','CFD','LMNA','DPT','HAS1','HAS2'))
BTCstroma <- AddModuleScore(BTCstroma, features = iCAF_genes, name = 'iCAF')
SpatialFeaturePlot(BTCstroma, features = 'iCAF1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC_iCAF.png")

# myCAFs
myCAF_genes <- list(c('TAGLN','MYL9','TPM2','MMP11','POSTN','HOPX','TWIST1','SOX4'))
BTCstroma <- AddModuleScore(BTCstroma, features = myCAF_genes, name = 'myCAF')
SpatialFeaturePlot(BTCstroma, features = 'myCAF1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC_myCAF.png")

# apCAFs
apCAF_genes <- list(c('HLA-DRA','HLA-DPA1','CD74','HLA-DQ','SLPI'))
BTCstroma <- AddModuleScore(BTCstroma, features = apCAF_genes, name = 'apCAF')
SpatialFeaturePlot(BTCstroma, features = 'apCAF1', images = 'slice1', pt.size.factor = 5)
ggsave("BTC_apCAF.png")
```

### Module score analysis for Hallmark Pathways for Epithelial (responding, non-responding, normal) Cells
```{r}
load("BTC_Epithelial.Rda")

# loading and create a list of MSigDB Hallmark pathways
hallmark_pathways = msigdbr(species = "Homo sapiens", category = "H")
hallmark_list <- split(hallmark_pathways$gene_symbol, hallmark_pathways$gs_name)


# loop for calculating module scores
for (pathway in names(hallmark_list)) {
  BTCepit <- AddModuleScore(
    object = BTCepit,
    features = list(hallmark_list[[pathway]]),
    name = pathway,
    ctrl = 5
  )
  
  # Plot the SpatialFeaturePlot
    plot <- SpatialFeaturePlot(BTCepit, features = paste0(pathway, "1"))
    print(plot)
  
  # Save the plot
    ggsave(filename = file.path(paste0(pathway, "_feature_plot.png")), plot = plot, width = 8, height = 6)
}

head(BTCepit@meta.data)

save(BTCepit, file = 'BTCepit_modscores.Rda')
```

### module scores violin plots
```{r}
# subsetting data for violin plots
epit_meta <- BTCepit@meta.data

# creating groups for statistical comparisons
mycomparisons <- list(c('normal duct','responding'), c('normal duct','non-responding'), c('responding','non-responding'))

# loop for module scores
for (pathway in names(hallmark_list)) {
  pathway_name <- paste0(pathway, "1")
  
  # Check if the pathway score exists in the metadata
  if (pathway_name %in% colnames(epit_meta)) {
    p <- ggplot(epit_meta, aes(x = CODA, y = .data[[pathway_name]])) + 
      geom_violin(aes(fill = CODA)) +
      geom_jitter(shape = 16, position = position_jitter(0.2)) +
      scale_x_discrete(name = 'Cell Type', limits = c("normal duct", "responding", "non-responding")) + 
      stat_compare_means(comparisons = mycomparisons) +
      ggtitle(pathway)
    
    # Save the plot
    ggsave(filename = file.path(paste0(pathway, "_violin_plot.png")), plot = p, width = 8, height = 6)
    
    print(p)
  
  }
}
```

## Incorporating the epithelial and CAF module scores into the complete Seurat object
```{r}

```

